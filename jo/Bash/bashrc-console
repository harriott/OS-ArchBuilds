#!/bin/sh
# vim: ft=sh sw=2:

# $Bash/bashrc-console  symlinked in  $bSc/symlinks/jo-0.sh  to  /home/jo/.bashrc-console
# sourced by  $Bash/bash_profile  &  $machBld/jo/Bash/bashrc
# useful also in Console as user

# -----------------------------------------------------------
# These are more settings that can also be useful in Console.
# -----------------------------------------------------------

# Joseph Harriott

export loaded_bc=1  # used in  $OSAB/bs-symlinks/repair.sh

ra () {
  pactl set-sink-volume 0 60%  # master volume to non-distorting level
  if [ $1 ]; then o=$1; else o=a; fi
  rec -c 2 $o.flac  # SoX
} # ra <stereoAudioRecording>

# Emacs
G (){ emacs --no-splash -fh $1 & }  # GUI
T (){ emacs -nw $1; }  # in terminal

#=> Bash interface
alias o=echo

# bigger command history
export HISTFILESIZE=10000  # lines
export HISTSIZE=1000  # commands
# defaults are 500

# command not found hook
source /usr/share/doc/pkgfile/command-not-found.bash

# for nnn & tmux
export EDITOR=nvim
export VISUAL=gvim

# pipx shell completions
eval "$(register-python-argcomplete pipx)"

#==> prompt
# a colorised (bold blue) prompt, with git support
source /usr/share/git/completion/git-prompt.sh
GIT_PS1_SHOWDIRTYSTATE=true
GIT_PS1_SHOWUNTRACKEDFILES=true
GIT_PS1=$(__git_ps1 " (%s)")  # comment out if entering a huge repository such as  nerd-fonts
longPrompt='\[\e[1;34m\][\w$GIT_PS1]\$\[\e[0m\] '
shortPrompt=false
PS1=$longPrompt

# toggle short prompt
sp (){
  if $shortPrompt; then
    PS1=$longPrompt
    shortPrompt=false
  else
    PS1='\[\e[1;34m\][\W]\$\[\e[0m\] '
    shortPrompt=true
  fi
}

#=> file manage
alias rsA0='bash $onGH/rsync-portabledrives/rsync-Dr0archive.sh'
alias rsA1='bash $onGH/rsync-portabledrives/rsync-Dr1archive.sh'

C (){
  if [ $1 ]; then
    CliFM -A $1
  else
    CliFM -A .
  fi
}  # CliFM (show hidden)
CliFM (){
  clifm --cd-on-quit --disk-usage --rl-vi-mode --trash-as-rm "$@"
  dir="$(grep "^\*" "/home/jo/.config/clifm/.last" 2>/dev/null | cut -d':' -f2)";
  [ -d "$dir" ] && cd -- "$dir"
} # C <dir1> [<dir2> ...]

locx () { locate -i $1 | xcol $1; }

#==> dts
# date time-sorted lists of files

fa () {
  eval "find * $printfDTsort"
}  # all files

fRs () {
  echo "directory: $1"
  echo "file glob to find: $2"
  if [ $2 ]; then
    tf=$rsnapshot/tds_find
    echo "$1 $2" > $tf
    echo '' >> $tf
    eval "find $rsnapshot/*/localhost$1 -type f -name \"*$2*\" $printfDTsort" >> $tf
    echo '- now look in  $rsnapshot/tds_find'
  else
    echo "fdtsRsnapshot <directoryToSearchIn> <fileToSearchFor>"
  fi
} # no spaces in arguments

#===> by extension
alias fx='fdtsExt'
# fx gfm
# fx gitignore  # $DJH/dts-gitignore.list

fdtsExt () {
  if [ $1 ]; then
    fdtsKSsearch="*.$1"; [[ $1 = 'gitignore' ]] && fdtsKSsearch=".$1"
    [[ $1 = "py" || $1 = "tex" ]] && fdtsKSprune=$'-path \'*/JH/copied/*\' -prune -o -path \'*/CGHrepos/*\' -prune -o -path \'*/vimfiles/*\' -prune -o'
    # still allows  fx tex  in  $copied, $CGHrepos, &  $vimfiles
    fdtsKSlist=dts-$1.fetl
    fdtsKS
    # [[ $1 = @(gitignore|pl|tex|txt) ]] && sed -i "s| \.| $PWD|" $fdtsKSlist
  else
    echo "^ need a file type (= filename extension)"
  fi
}

#===> by keystring in name
alias fk=fdtsKeyString

fdtsKeyString () {
  if [ $1 ]; then
    fdtsKSlist=dts-$1_in_name.fetl
    search='\*$1\*'
    eval "fdtsKS $search $dtsfile"
  fi
}

#===> common functionality
export printfDTsort='-printf %TY-%Tm-%Td\ %TH:%TM\ %p\\n | sort'
fdtsListHeader () { echo "" > $1; echo $PWD >> $1; echo "" >> $1; }

fdtsKS () {
  fdtsListHeader $fdtsKSlist
  eval "find . $fdtsKSprune -iname \"$fdtsKSsearch\" $printfDTsort >> $fdtsKSlist"
  echo "" >> $fdtsKSlist
  echo "results are in $fdtsKSlist"
} # internal use only

#===> my Arch Forum issues
# $jtIT/dts-ft_bbcode.fetl
# $ITstack/dts-ft_bbcode.fetl

fdtsbbcode () {
  dtsfile=dts-ft_bbcode.fetl
  fdtsListHeader $dtsfile
  rg -ttxt -l --sort modified 'ft=bbcode' >> $dtsfile
  echo "results are in $dtsfile"
}

#==> file mime types
fmtypes () {
  fml=file-mime.list
  echo "vim: ft=fileMimeList:" > $fml
  echo "" >> $fml
  fd -tf -x file -i {} | sort >> $fml
  echo "" >> $fml
}

#==> filetype frequencies
exts () { fd -tf -u '\..+' | sed -n 's/..*\.//p' | sort | uniq -c; } # sorted by extensions

ve () {
  exts > exts0
  sed -i 's/^ \+//' exts0
  sed -i 's/ /`/' exts0
  sed -i 's/\r/ /' exts0
  sort -nr exts0 > exts1; rm exts0
  sed -i '0,/^1`/ s/^1`/\n1`/' exts1  # add line before counts of 1, which could be many
  paste -sd ' ' exts1 > exts.exts; rm exts1  # concatenate all lines
  sed -i '1i\\' exts.exts  # prepend a blank line
  sed -i 's/  /\n\n/' exts.exts  # separate out those counts of 1
  echo '' >> exts.exts
  echo "- now look in exts.exts"
} # sorted by frequency, making use of  $vimfiles/syntax/exts.vim

#==> Git
# fx gitignore

alias ga='git add'
alias gis='git status -u'
export BFG=$CrPl/bfg-1.13.0.jar
gic () { git commit -m "$1"; }

#===> time-sorted - .git/config
# $ITstack/git_config.fetl

gitc () {
  gitcl=git_config.fetl
  echo '' > $gitcl
  for f in $(fd -HI -tf ^config$); do sm $f; done | sort >> $gitcl
  echo "results are in $gitcl"
}

#===> time-sorted - my GitHub issues
# $jtIT/GitHubIssues.fetl
# $ITstack/GitHubIssues.fetl

ghi () {
  ghil=GitHubIssues.fetl
  for f in $(rg -l -tmd 'github.com.+issues'); do sm $f; done | sort > $ghil
  sed -i '/copied\/IT-handy\//d' $ghil
  sed -i '1s/^/\n/' $ghil
  echo '' >> $ghil
  echo "results are in $ghil"
}

#==> lists of files by content
rgIT () {
  cd $DJH/search
  f=IT-rg.fetl  # $DJH/search/IT-rg.fetl
  for ITd in $jtIT $ITstack; do
    rgc="rg -l $1 $ITd"
    echo '' >> $f; echo $rgc >> $f
    echo '' >> $f; $rgc >> $f; echo '' >> $f
  done
  echo "- now open  $DJH/search/IT-rg.fetl"
}

SE () {
  cd $DJH/search
  f=SEN.fetl
  [ -s $f ] && rm $f
  echo '' > $f; echo 'SE  -see  $Bash/bashrc-console'
  for ITd in $jtIT $ITstack $JHw/France; do
    echo '' >> $f
    rg -l -tmd 'stackexchange|stackoverflow' $ITd | sort >> $f
  done
  echo '' >> $f
  echo 'now open $DJH/search/'$f
}

#==> my Encrypted directories
#  fa | grep Digital0
#  fa | grep Secure0
#  fa | grep Secure1
#  fa | grep Stack

#===> quick-check
alias fe='fdtsEncryptedChanges'

Encrypted=(Digital0 Digital1 Secure0 Secure1 SHG Stack)
fdtsEncryptedChanges () {
  if [ "$PWD" != $Enc ]; then
    if [ -d "$Enc" ]; then
      cd $Enc; pwd
    else
      echo "$Enc ain't there"; return
    fi
  fi
  for E in ${Encrypted[@]}; do
    f7z="find . -iname \"$E*.7z\" | sort | tail -1"
    ed7z=$(eval "$f7z")
    if [ $ed7z ]; then
      tput setaf 5
      eval "find . -iname \"$E*.7z\" $printfDTsort"
      tput setaf 7
      eval "find -path \"./$E*\" -newer $ed7z $printfDTsort"
      # - fails to detect change of year
      eval "find \"$core/encrypted\" -name \"$E*\" -newer $ed7z"
    fi
  done
}

#==> only useful in sbMb
# and not needed as root

if [ $host = 'sbMb' ]; then

  alias rsM='bash $onGH/FM-rsync-drives/sbMb/Music.sh'
  alias rsV='bash $onGH/FM-rsync-drives/sbMb/Vs.sh'
  alias rsVe='bash $onGH/FM-rsync-drives/sbMb/Vs-extra.sh'

  fS () {
    find /mnt/WD30EZRZ/Sync2 -type f -name "*$1*"
  }

fi

#==> Samokovarov's  jump
if [ -s "/usr/bin/jump" ]; then
  eval "$(jump shell)"  # makes further adjustments to  PROMPT_COMMAND
fi

#==> trash-cli
alias gte='gio trash --empty'
alias tl='trash-list'
alias tre='trash-restore'

#=> human language - dict
alias del='dict -d elements'  # del iron

# English:
alias dmt='dict -d moby-thesaurus'  # dmt fuck
alias dwn='dict -d wn'  # dwn fuck

# French translate
alias def='dict -d fd-eng-fra'  # def fuck
alias dfe='dict -d fd-fra-eng'  # dfe facture

#=> human language - Verbiste
alias decon='french-deconjugator'  # decon aimâmes

con () {
  fco=$(french-conjugator "$1")
  oneline="${fco//$'\n'/ }"
  trimmed="$(echo "$oneline" | cut -c 3- | rev | cut -c 3- | rev)"
  flagged="${trimmed//$' - '/≡}"
  IFS='≡' read -r -a array <<< "$flagged"
  for conjugation in "${array[@]}"; do
    tense=$(echo "$conjugation" | sed 's/:.\+//')
    conjugations=$(echo "$conjugation" | sed 's/.\+: //')
    spaced=$(echo "$conjugations" | sed 's/ /  /g')
    echo -e "\e[32m $tense \e[1;33m $spaced \e[0m"
  done
} # con <a_French_infinitive>

#=> nnn
[ -n "$NNNLVL" ] && PS1="N$NNNLVL $PS1"

n() {
  # no nesting of nnn in subshells
    [ "${NNNLVL:-0}" -eq 0 ] || { echo "nnn is already running"; return; }
  NNN_TMPFILE=${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd  # cd on quit only on ^G
  [ -s "/usr/bin/cpg" ] && progress=-r  # advcpmv is installed
  command nnn $progress -Q -U "$@"
  if [ -f $NNN_TMPFILE ]; then
    # ~/.config/nnn/.lastd  was created when quitting  nnn, so
    . $NNN_TMPFILE
    rm -f $NNN_TMPFILE > /dev/null
  fi
}

# ~/.config/nnn/.selection - only when I've selected some files

source $ulLA/jo/bashrc-console-NNN_BMS  # my bookmarks
export NNN_COLORS='5723' # good for my tmux in urxvt
export NNN_PLUG='c:fzcd;d:dragdrop;i:ipinfo;o:fzopen;m:mediainf;t:treeview;u:uidgid'  # quit treeview's nvim with ZQ
export NNN_TRASH=1 # trash (needs trash-cli) instead of delete
export NNN_LOCKER='saidar -c' # for 0

#=> npm global directory
export PATH="$HOME/.npm-global/bin:$PATH"

#=> pipx exposed binaries
export PATH="$PATH:$HOME/.local/bin"  # for  pipx  installed commands

#=> Ruby gems
if [ -s "/usr/bin/ruby" ]; then
  export GEM_HOME="$(ruby -e 'puts Gem.user_dir')"
  export PATH="$PATH:$GEM_HOME/bin"
fi

#=> system
alias i=pinfo
alias im='pinfo -m'
export GPG_TTY=$(tty)  # correct TTY for GnuPG

#==> for AUR packages
# "Get Clone To Make" - for my building of AUR development packages
gctm(){ cd $HOME/Arch/AURdev-make; rAUR $1; cp -r ../AURdev-clone/$1 $1; cd $1; }; export -f gctm

# get into an AUR repository
gAUR () { cd "$HOME/Arch/AUR$2"; rAUR $1; trizen -G $1; cd $1; }; export -f gAUR
# if fail to enter pw in time for trizen, pacman -U package_name-version.pkg.tar.xz

# get into an AUR development repository
gdAUR () { gAUR $1 dev-clone; gctm $1; }; export -f gdAUR

# remove an AUR repository if it's there
rAUR(){ [ -d $1 ] && sudo rm -r $1; }; export -f rAUR

