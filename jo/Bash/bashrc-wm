# vim: ft=sh sw=2:

# stuff that's useful when a Window Manager is installed

alias xc="zathura -P 38 $IThandy/TeX/LaTeX/Appearance/colour/xcolor.pdf &"

fv () {
    # find $Vs -type f -name "*$1*"
    Vss=($(find $VsLocation -mindepth 1 -maxdepth 1 -type d -name "Vs*" 2>/dev/null))
    for Vs in "${Vss[@]}"; do
        find $Vs -iname "*$1*" | xcol "$1"
    done
} # fv 'Dog Vision'

ltx () {
  cd $LTX
  s="sectionHeadings.md"
  > $s
  for f in **/*.tex; do
    echo '' >> $s
    echo "# ${f%.tex}" >> $s
    echo "\$LTX/$f" >> $s
    echo '' >> $s
    sed -e '/section{/!d' $f >> $s
  done
  echo '' >> $s
  sed -i 's/\\section{/    /' $s
  sed -i 's/\\subsection{/        /' $s
  sed -i 's/\\subsubsection{/            /' $s
  sed -i 's/}//' $s
}

#=> audio trimming
aet () {
  export a="$1"
  trim=1; [[ $2 ]] && [[ $2 -gt '1' ]] && trim=$2
  duration=$(ffprobe -i "$a" -show_format -v quiet | sed -n 's/duration=//p')
  trimmed=$(echo "$duration-$trim" | bc)
  ffmpeg -i "$a" -c copy -t $trimmed -y "t$a"
  mpv --start=-3 "t$a"
} # aet <anAudioFileToTrimOffEnd> <trimIfGreaterThan1second>

abt () {
  export a="$1"
  trim=1; [[ $2 ]] && [[ $2 -gt '1' ]] && trim=$2
  ffmpeg -ss $trim -i "$a" -c copy -y "t$a"
  mpv --end=3 "t$a"
} # abt <anAudioFileToTrimOffBeginning>

# mv "t$a" "$a"

#=> CUPS
alias lpd='lpstat -p -d'
alias sc5='sudo cupsenable ENVY_5530'

#=> ffmpeg
alias ffmhb='nice -n 19 ffmpeg -hide_banner'

frames () {
  ffmpeg -i $1 -vcodec copy -f rawvideo -y /dev/null 2>&1
} # $1 mustn't contain spaces...

vs () {
  if [ $1 ]; then
    if [ $2 ]; then
      if [[ $2 == '0' || $2 == '1' ]]; then
        trfs=($(find . -maxdepth 1 -type f -name "*.trf"))
        trfs=(${trfs[@]/#\.\//})  # remove leading ./
        nt=${#trfs[@]}  # number of trf's
        if [[ $nt == 0 ]]; then
          echo "step 1: vs <video_to_stabilise>" # because no trf file has been made
        else
          if [[ $nt == 1 ]]; then
            trf=${trfs[0]}  # only one trf file
          else
            echo ${trfs[@]}
            read -p "choose an index " ti
            if [[ $ti =~ ^[0-9]+$ ]] && [ $ti -ge 0 ] && [ $ti -le $((nt-1)) ]; then
              # $ti is an integer, and within the range of $trfs
              trf=${trfs[$ti]}
            else
              echo "bad index"
              unset trf
            fi
          fi  # a trf file has been selected, or not
          if [ $trf ]; then
            auc='-an'
            (( $2 )) && auc='-c:a copy'
            shv=($(find . -maxdepth 1 -type f -name "${trf%.*}.*" ! -name $trf))  # divine the shaky video file
            shv=(${shv[@]/#\.\//})  # remove leading ./
            if [ $shv ] && [ -s $shv ]; then
              echo "====== ${tpf2b}vs${tpfn} step 2 stabilising ${tpf2b}$shv${tpfn} with ${tpf2b}$trf${tpfn} to ${tpf2b}$1${tpfn} ======"
              ffmpeg -i $shv -vf vidstabtransform=input=$trf:zoom=0:smoothing=10,unsharp=5:5:0.8:3:3:0.4 -tune film $auc $1
            else
              rm $trf
              echo "removed dangling $trf"
            fi
          fi
        fi
      else
        echo "vs 2nd argument: 0 = no audio, 1 = copy audio"  # vs la2-stabilised.mp4 0
      fi
    else
      vfbn=${1%.*}
      if [ -s $1 ]; then
        echo "====== ${tpf2b}vs${tpfn} 1 getting transform vectors for ${tpf2b}$1${tpfn} ======"
        ffmpeg -i $1 -vf vidstabdetect=stepsize=32:shakiness=10:accuracy=10:result=${1%.*}.trf -f null -
      else
        echo "vs <video_to_stabilise>"  # vs MOV_0001.mp4
      fi
    fi
  else
    echo "step 1: ${tpf2b}vs <video_to_stabilise>${tpfn}  step 2: ${tpf2b}vs <stabilised_video> <audio_choice>${tpfn}"
  fi
}  # stabilize a video

#=> gVim cautious
gvc () {
    textfilefullpath=$(cd "$(dirname "$1")"; pwd -P)/$(basename "$1")
    vimswapfile=${textfilefullpath//\//%}.swp
    vimswapfilepath=~/.vimswap/$vimswapfile
    if [[ -f $vimswapfilepath ]]; then
       echo "$vimswapfilepath exists"
    else
       gvim $1
    fi
} # opens the file in gVim only if there's no swap file present for it

#=> imagey - convert scanned images to jpg with ImageMagick
# (won't work with white-spaces in file names)
c () {
  bash $Imagey/cnvt.sh $1 "-quality 70"
}
cg () {
  bash $Imagey/cnvt.sh $1 "-colorspace gray -quality 80"
}
cr () {
  bash $Imagey/cnvt.sh $1 -resize $2
}
crg () {
  bash $Imagey/cnvt.sh $1 "-colorspace gray -resize" $2
}
cld () { # darken, and slightly reduce filesize
  bash $Imagey/cnvt.sh $1 "-level 25%,100%,.5 -quality 50"
}
clm () { # lose lighter stuff, darken, and slightly reduce filesize
  bash $Imagey/cnvt.sh $1 "-level 25%,75%,.5 -quality 50"
}

#=> imagey - copy a directory of sketches darker
dsd () {
  bash $Imagey/gamma03.sh $1
}

#=> imagey - jpeg orientation
# Recursively find all *.jpg (- that's case insensitive) files in the current directory
# and set  -orientation=Horizontal   if necessary.
jpo () {
  exiftool -r -ext jpg -overwrite_original -orientation=Horizontal -progress -if '$orientation =~ /Rotate/' .
}

#=> imagey - lighten an image
cl () {
  inimag=${1%.*}
  convert $1 -level 0,75% -quality 80 $inimag-l.jpg
}

#=> imagey - SANE's scanimage tool
S () {
  bash $Imagey/Scan.sh $1 $2 $3 $4
}

#=> Pandoc my markdown notes
for iHS in {0..1}; do  # setup alternative commands to define the header style
    setHeadingsSty[$iHS]="ln -sf $MD4PDF/iih/headings$iHS.sty ~/texmf/tex/latex/m4p/headings.sty"
  done  # (leaves iHS set to 1)

m4p() # a single TextNote file
{
    eval ${setHeadingsSty[0]}
    export headingtoodeep=######
    export m4pfont=0
    bash $MD4PDF/GNULinux/m4p.sh $1 $2
}

# recursively compile from many markdowns
m4ps0() # my TextNotes
{
    eval ${setHeadingsSty[0]}
    export headingtoodeep=######
    export m4pfont=0
    bash $MD4PDF/GNULinux/m4ps.sh $1 $2
} # 2nd argument turns off ToC

m4ps1() # muted headings
{
    eval ${setHeadingsSty[1]}
    export headingtoodeep=####
    export m4pfont=1
    bash $MD4PDF/GNULinux/m4ps.sh 0 1
}

mt() # do my TextNotes
{
    cd $DROPBOX/JH/core/TextNotes
    pwd
    m4ps0 0
    figlet -f univers done
}

